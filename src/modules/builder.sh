#!/bin/bash

# Builder Module

setup_build_environment() {
    # Use APP_NAME and ARCH which are set in config module
    BUILD_DIR="${SCRIPT_DIR}/${APP_NAME}-AppDir"
    APPIMAGE_TOOL="${SCRIPT_DIR}/appimagetool-${ARCH}.AppImage"
    OUTPUT_FILE="${SCRIPT_DIR}/${APP_NAME}-${ARCH}.AppImage"
    
    # Handle existing build directory
    if [[ -d "$BUILD_DIR" ]]; then
        if [[ "$FORCE_REBUILD" == "true" ]]; then
            log "INFO" "Removing existing build directory: $BUILD_DIR"
            rm -rf "$BUILD_DIR"
        else
            die "Build directory already exists: $BUILD_DIR (use --force to overwrite)"
        fi
    fi
    
    # Handle existing AppImage
    if [[ -f "$OUTPUT_FILE" ]]; then
        if [[ "$FORCE_REBUILD" == "true" ]]; then
            log "INFO" "Removing existing AppImage: $OUTPUT_FILE"
            rm -f "$OUTPUT_FILE"
        else
            die "AppImage already exists: $OUTPUT_FILE (use --force to overwrite)"
        fi
    fi
}

create_appdir_structure() {
    log "INFO" "Creating AppDir structure..."
    
    # Create directory structure
    mkdir -p "$BUILD_DIR/usr/bin"
    mkdir -p "$BUILD_DIR/usr/share/icons/hicolor/${ICON_SIZE}x${ICON_SIZE}/apps"
    mkdir -p "$BUILD_DIR/usr/share/applications"
    
    # Handle Project Mode or Legacy Mode
    if [[ -n "${PROJECT_ROOT:-}" ]]; then
        log "INFO" "Project mode: Copying project from $PROJECT_ROOT"
        cp -r "$PROJECT_ROOT"/* "$BUILD_DIR/usr/bin/"
        chmod +x "$BUILD_DIR/usr/bin"
    else
        # Legacy mode: single script
        cp "$INPUT_SCRIPT" "$BUILD_DIR/usr/bin/$APP_NAME"
        chmod +x "$BUILD_DIR/usr/bin/$APP_NAME"
    fi
    
    log "SUCCESS" "Application content copied to $BUILD_DIR/usr/bin"

    # Copy extra assets if provided
    if [[ -n "${ASSETS_DIR:-}" ]]; then
        if [[ -d "$ASSETS_DIR" ]]; then
            log "INFO" "Copying assets from $ASSETS_DIR..."
            cp -r "$ASSETS_DIR"/* "$BUILD_DIR/usr/bin/"
            log "SUCCESS" "Assets copied."
        else
            log "WARN" "Assets directory not found: $ASSETS_DIR"
        fi
    fi
}

create_icon() {
    local icon_path="$BUILD_DIR/usr/share/icons/hicolor/${ICON_SIZE}x${ICON_SIZE}/apps/${APP_NAME}.png"
    
    if [[ -n "${CUSTOM_ICON:-}" ]]; then
        log "INFO" "Using custom icon: $CUSTOM_ICON"
        if command -v convert &> /dev/null; then
            convert "$CUSTOM_ICON" -resize "${ICON_SIZE}x${ICON_SIZE}" "$icon_path"
        else
            cp "$CUSTOM_ICON" "$icon_path"
        fi
    else
        log "INFO" "Creating default icon..."
        if command -v convert &> /dev/null; then
            convert -size "${ICON_SIZE}x${ICON_SIZE}" \
                    -background "#4a90e2" \
                    -fill white \
                    -gravity center \
                    -pointsize $((ICON_SIZE / 6)) \
                    label:"${APP_NAME:0:3}" \
                    "$icon_path"
        else
            # Create placeholder file
            touch "$icon_path"
            log "WARN" "Created placeholder icon (ImageMagick not available)"
        fi
    fi
    
    log "SUCCESS" "Icon created: $icon_path"
    
    # Also copy icon to root of AppDir as required by AppImage spec
    cp "$icon_path" "$BUILD_DIR/${APP_NAME}.png"
    # And as .DirIcon for file managers
    cp "$icon_path" "$BUILD_DIR/.DirIcon"
}

create_desktop_file() {
    local desktop_file="$BUILD_DIR/$APP_NAME.desktop"
    
    log "INFO" "Creating desktop file..."
    
    cat > "$desktop_file" <<EOF
[Desktop Entry]
Name=$APP_NAME
Exec=$APP_NAME
Icon=$APP_NAME
Type=Application
Categories=$CATEGORIES
Terminal=$TERMINAL_APP
Version=1.0
Comment=Shell script packaged as AppImage
Keywords=shell;script;utility;
StartupNotify=true
EOF
    
    log "SUCCESS" "Desktop file created: $desktop_file"
}

create_apprun() {
    local apprun_file="$BUILD_DIR/AppRun"
    
    log "INFO" "Creating AppRun file..."
    

    # Determine AppRun content based on mode
    if [[ "$TEMP_MODE" == "true" ]]; then
        log "INFO" "Generating wrapper AppRun for temp mode..."
        cat > "$apprun_file" <<EOF
#!/bin/bash
# Autogenerated AppRun by To_Appimage (Temp Mode)

# Get the AppImage mount point
APPDIR="\$(dirname "\$(readlink -f "\$0")")"

# Create a temporary working directory
WORK_DIR=\$(mktemp -d -t ${APP_NAME}-XXXXXX)

# Copy application files to the temp working directory
# We use -a to preserve permissions/attributes
cp -a "\$APPDIR/usr/bin/." "\$WORK_DIR/"

# Ensure executable permissions
chmod -R +x "\$WORK_DIR"

# Set PATH to include WORK_DIR
export PATH="\$WORK_DIR:\$PATH"
# Set LD_LIBRARY_PATH (optional but standard)
export LD_LIBRARY_PATH="\$APPDIR/usr/lib:\$LD_LIBRARY_PATH"

EOF
        # Execution command
        if [[ -n "${PROJECT_ROOT:-}" ]]; then
            # Calculate relative path similar to standard mode
            local abs_project
            abs_project=$(readlink -f "$PROJECT_ROOT")
            local abs_script
            abs_script=$(readlink -f "$INPUT_SCRIPT")
            local relative_path="${abs_script#$abs_project/}"
            echo "exec \"\$WORK_DIR/$relative_path\" \"\$@\"" >> "$apprun_file"
        else
            echo "exec \"\$WORK_DIR/$APP_NAME\" \"\$@\"" >> "$apprun_file"
        fi
        
    else
        # Standard AppRun generation
        cat > "$apprun_file" <<EOF
#!/bin/bash
# Autogenerated AppRun by To_Appimage

# Get the directory where this AppRun script is located
APPDIR="\$(dirname "\$(readlink -f "\$0")")"

# Set up environment
export PATH="\$APPDIR/usr/bin:\$PATH"
export LD_LIBRARY_PATH="\$APPDIR/usr/lib:\$LD_LIBRARY_PATH"

# Execute the wrapped script
EOF

        # Determine what to execute (Standard Mode)
        if [[ -n "${PROJECT_ROOT:-}" ]]; then
            local abs_project
            abs_project=$(readlink -f "$PROJECT_ROOT")
            local abs_script
            abs_script=$(readlink -f "$INPUT_SCRIPT")
            local relative_path="${abs_script#$abs_project/}"
            
            echo "exec \"\$APPDIR/usr/bin/$relative_path\" \"\$@\"" >> "$apprun_file"
        else
            echo "exec \"\$APPDIR/usr/bin/$APP_NAME\" \"\$@\"" >> "$apprun_file"
        fi
    fi


    cat >> "$apprun_file" <<EOF
EOF
    
    # Make it executable
    chmod +x "$apprun_file"
    
    log "SUCCESS" "AppRun file created: $apprun_file"
}

build_appimage() {
    log "INFO" "Building AppImage..."
    
    # Make sure the AppImage tool is executable
    chmod +x "$APPIMAGE_TOOL"
    
    # Build the AppImage
    if ! ARCH="$ARCH" "$APPIMAGE_TOOL" "$BUILD_DIR" &>> "$LOG_FILE"; then
        die "Failed to build AppImage. Check $LOG_FILE for details."
    fi
    
    # Find the created AppImage (appimagetool might change the name)
    local created_appimage
    created_appimage=$(find "$SCRIPT_DIR" -name "${APP_NAME}*.AppImage" -newer "$BUILD_DIR" | head -n1)
    
    if [[ -z "$created_appimage" ]]; then
        die "AppImage was not created successfully"
    fi
    
    # Rename to expected filename if different
    if [[ "$created_appimage" != "$OUTPUT_FILE" ]]; then
        mv "$created_appimage" "$OUTPUT_FILE"
    fi
    
    log "SUCCESS" "AppImage created: $OUTPUT_FILE"
}

cleanup() {
    local success="$1"
    
    if [[ "$success" == "true" && "$CLEANUP_ON_SUCCESS" == "true" ]]; then
        log "INFO" "Cleaning up build directory..."
        rm -rf "$BUILD_DIR"
    elif [[ "$success" == "false" && "$CLEANUP_ON_FAILURE" == "true" ]]; then
        log "INFO" "Cleaning up build directory after failure..."
        rm -rf "$BUILD_DIR"
    fi
}
